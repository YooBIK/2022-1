Protocol
-Human protocols : 사람들사이의 상호작용하는 규칙
-Networking protocols : 네트워크로 연결된 시스템에서 적용되는 규칙(ex. HTTP,FTP)
-Security protocol : 보안 시스템에서 사용되는 규칙(TLS, IPSec, Kerberos, etc)

프로토콜은 굉장히 민감하게 사용된다.
제대로된 프로토콜을 설계하는 것은 어렵고, 그 과정에서 만족시켜야할 조건이 많음

이상적인 보안 프로토콜
1.보안 측면의 요구사항을 충족 시켜야한다.
2.계산요구를 최소화 해야함(효율성)
3.공격자가 공격을 해도 시스템은 손상없이 정상 작동 해야한다.(견고성)
4.사용성, 구현용의성, 유연성 등
모든것을 충족시키기 굉장히 어려움!

아주 간단한 인증 프로토콜
Alice --("I'm Alice")--> Bob
Alice <--(Prove it)-- Bob
Alice --h(Alice's password)--> Bob
재연공격에 취약함

Nonce == Number used once

Alice --("I'm Alice")--> Bob
Alice <--Nonce-- Bob  		//(Challenge)
Alice --h(Alice's password,Nonce)--> Bob	//(Response)
이 상황에서 Bob은 구분하기 위해 Alice의 Password를 알고 있어야함

PKES(Passive Keyless Entry Systems) - challenge-response의 방식(자동차키로 차문여는거 같은경우)

Two-factor Authentication

MIG-in-the-Middle Attack


Authentication w/ Symmetric Key
A와 B가 대칭키K를 공유

A,K  --"I'm Alice"--> B,K
A,K  <--R(Nonce)-- B,K
A,K  --E(R,K)--> B,K
이 경우 B는 A임을 알지만 A는 B라는 것을 알 수 없음

A,K  --"I'm Alice"--> B,K
A,K  <--E(R,K)-- B,K
A,K  --E(R,K)--> B,K
이 경우는 받은 E(R,K)를 그대로 보내면 A가 아니여도 인증될 수도 있음

A,K  --"I'm Alice",Ra--> B,K
A,K  <--Rb,E(Ra,K)-- B,K
A,K  --E(Rb,K)--> B,K
reflection attack 가능

Public Key based Authentication

Session Key
A,K	--"I'm Alice",R--> 	B,K
A,K	<-{R,K}A--		B,K
A,K	--{R+1,K}B-->	B,K
B라는것을 인증할 수 없음(상호인증이 안됨)

A,K	--"I'm Alice",R--> 	B,K
A,K	<-[R,K]B--		B,K
A,K	--[R+1,K]A-->	B,K
상호 인증은 되지만, K값이 공개되어있어 안전하지 않음

A,K	--"I'm Alice",R--> 	B,K
A,K	<--{[R,K]B}A--	B,K
A,K	--{[R+1,K]A}B-->	B,K
상호 인증 + 세션키도 안전하게 공유 가능! 선서명 후암호화 방법

A,K	--"I'm Alice",R--> 	B,K
A,K	<--[{R,K}B]A--	B,K
A,K	--[{R+1,K}A]B-->	B,K
선암호화 후인증, 안전하지만, {R,K}B,{R+1,K}A 이 부분을 누구나 볼수 있어서 좀 찝찝함

PFS(Perfect Forward Secrecy) : 나중에도 다른 사람이 복호화 할 수 없게 함(나중에 K를 누가 알게되더라도)

Naive Session Kye protocol
A,Kab	----E(Ks,Kab)--> 		B,Kab
A,Kab	<--E(messages,Ks)--		B,Kab

Diffie-Hellman for PFS
//public g&p
Alice, a	-----g^a mod p -->	Bob, b
Alice, a	<-- g^b mod p----	Bob, b
Diffie-Hellman 과정을 통해 둘만 아는 키를 만들 수 있음
(Diffie-Hellman 알고리즘은 중간자 공격에 취약함!!)

Ephemeral Diffie-Hellman // 일회성 Diffie-Hellman
//Session key Ks = g^ab mod p
Alice, a	-----E(g^a mod p, Kab) -->	Bob, b
Alice, a	<-- E(g^b mod p, Kab)----	Bob, b
Alice와 Bob은 a와 b를 한번 사용하고 폐기한다. a,b를 모르면 Session키를 복구 할 수 없으므로 PFS를 보장한다

Mutual Authentication, Session Key and PFS
Alice, a	-----------"I'm Alice", Ra  ----------->	Bob, b
Alice, a	<-- Rb,[{Ra,g^b mod p}Alice]Bob----	Bob, b
Alice, a	-----[{Rb,g^a mod p}Bob]Alice-->	Bob, b
Alice 는 a를 Bob은 b를 잊는다.
상호인증도 가능하고, PFS를 보장한다.

Timestamps
Nonce는 먼저 Challenge를 주고Response를 받아야함(비효율적이다!)
timestamp T를 사용 시간개념만으로 효율성을 얻을 수 있음
시간의 오차를 허용하더라도 어느정도의 오차를 허용할지를 정하는 것이 중요함

Public Key based Authentication with Timestamp T
Alice	--"I'm Alice", {[T,K]Alice}Bob  -->	Bob
Alice	<------ {[T+1,K]Bob}Alice --------	Bob
여기서 K = g^a mod p , g^b mod p (Diffie-Hellman)
선 서명 후 암호화에 Timestamp를 적용한 것은 안전하다고 볼 수 있다.

Alice	--"I'm Alice", [{T,K]Bob}]Alice  -->	Bob
Alice	<------ [{T+1,K}Alice]Bob --------	Bob
선 암호화 후 서명은 안전하지 않다.

Nonce with 선 서명 후 암호화		안전
Nonce with 선 암호화 후 서명		안전
Timestamp with 선 서명 후 암호화	안전
Timestamp with 선 암호화 후 서명	위험