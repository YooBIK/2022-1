Cryptography - 암호를 생성
Cryptanalysis - 암호 해석
Cryptology - 암호학

cipher - 암호, 암호화 할때 사용됨 plaintext - 평문
plaintext -> encrypt암호화 -> ciphertext
ciphertext -> decrypt복호화 -> plaintext

key - 암호화를 구현하는 방법중 하나

대칭키, 비대칭키(private, public)

암호의 기본 전제
암호의 메커니즘 자체는 영원한 비밀이 될 수 없음
오직 키만 비밀이 될 수 있음

결국 암호 알고리즘은 뚫리고 공개됨
약점을 찾아 보완하는게 더 나은 해결방법

Shift cipher - 숫자를 키로 삼아서 키만큼 이동시킨 값으로 암호화
Transposition cipher - 문자를 치환시켜서 재배열
Substitution cipher - 각 문자를 다른문자로 대체
Vigenere cipher - 평문과 길이가 같은 암호키를 사용해서 암호화

안전하다는 기준? 
Computational security - 상대방이 사용할 수 있는 하드웨어보다 훨씬 더 많은 계산단계를 필요로 하면 Computational Security를 보장
Unconditional Security - 공격자가 무한한 계산능력을 사용 가능하다고 해도, 해석한 평문이 원문이랑 같은지 추론할 근거가 없다면 Unconditional Security 보장

Vernam Cipher/One time pad 	-평문과 길이가 같은 키를 사용함 Vigenere 와 비슷, 한번 사용한 암호는 폐기
			-문자를 0과1로 표현하여 키와 xor연산을 함 복호화도 xor연산을 통해 복호화
평문에 대한 정보를 전혀 제공하지 않아 Unconditional security 를 만족
키는 랜덤하게 단 한번만 사용가능하고(동일한 키로 여러번 암호화 하면 원문과 키를 유추할 수 있음), 키값이 평문과 길이가 같아야하고, 반드시 키를 공유해야하기 때문에 비효율적임

Zimmerman Telegram - 단어 - 숫자 매칭 사전마냥 찾아서씀 codebook

Random functions(hash functions) - 어떤 길이의 인풋이 있던간에 고정된 길이의 결과가 나옴
Random generators(stream cipher) - 연속적인 인풋에 대해 연속적인 아웃풋을 생성
Random permutations(block cipher) - 고정된 사이즈의 인풋으로 고정된 사이즈의 아웃풋을 생성
Public Key encryption(block cipher의 특수한 경우) - 모두가 암호화 할 수 있지만, Private key 의 소유자만 복호화 가능
Digital signatures(디지털 서명) - 키의 주인만 서명 가능, 누구나 확인할 수 있음

Hash Function 	- 특정 input에는 특정 output이 나오는 함수를 통해 암호화
		- 압축의 효과가 있음
		- 계산이 쉽고 효율적임
		- 단방향성, input X를 통해 output Y를 도출했더라도, Y를 통해 X를 추론할 수 없음
		- 약한 충돌 저항성, x와h(x)를 알고 있을 때, h(x)=h(y) && x!=y를 찾을 수 없고 가능하더라도 무시할만한 확률임 
		- 강한 충돌 저항성, 아무 정보가 없는 상태에서 x!=y && h(x)=h(y)를 찾는게 사실상 불가능하다.
